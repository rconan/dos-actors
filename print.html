<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GMT DOS ACTORS</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="gmt-actor-model/gmt-actor-model.html"><strong aria-hidden="true">1.</strong> GMT Actors Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gmt-actor-model/actors/actors.html"><strong aria-hidden="true">1.1.</strong> Actors</a></li><li class="chapter-item expanded "><a href="gmt-actor-model/data/data.html"><strong aria-hidden="true">1.2.</strong> Data</a></li><li class="chapter-item expanded "><a href="gmt-actor-model/model/model.html"><strong aria-hidden="true">1.3.</strong> Model</a></li><li class="chapter-item expanded "><a href="gmt-actor-model/clients/client.html"><strong aria-hidden="true">1.4.</strong> Clients</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gmt-actor-model/clients/sig-log/sig-log.html"><strong aria-hidden="true">1.4.1.</strong> Signals & Logger</a></li><li class="chapter-item expanded "><a href="gmt-actor-model/clients/feedback/feedback.html"><strong aria-hidden="true">1.4.2.</strong> Feedback System</a></li><li class="chapter-item expanded "><a href="gmt-actor-model/clients/multirate/multirate.html"><strong aria-hidden="true">1.4.3.</strong> Multirate System</a></li><li class="chapter-item expanded "><a href="gmt-actor-model/clients/persistence/persistence.html"><strong aria-hidden="true">1.4.4.</strong> Persistence</a></li></ol></li><li class="chapter-item expanded "><a href="gmt-actor-model/aggregation/aggregation.html"><strong aria-hidden="true">1.5.</strong> Aggregation</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GMT DOS ACTORS</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rconan/dos-actors/tree/main/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><code>gmt_dos-actors</code> is the Rust crate that is the backbone of the computing framework for the integrated model of the <a href="https://www.gmto.org">Giant Magellan Telescope</a>.
It is based on the <a href="https://en.wikipedia.org/wiki/Actor_model">actor model</a> but specially adapted for integrated modeling purposes.</p>
<p>In order to use the crate, you must have <a href="https://www.rust-lang.org">Rust</a> installed on your machine and be <a href="https://www.rust-lang.org/learn">familiar</a> with the Rust language
The minimum Rust version for the <code>gmt_dos-actors</code> is 1.66.0</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmt-actors-model"><a class="header" href="#gmt-actors-model">GMT Actors Model</a></h1>
<p>A GMT integrated model is a collection of actors, each actor executing a specific task or set of tasks and exchanging data at predefined sampling rates.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="actors"><a class="header" href="#actors">Actors</a></h1>
<p>An actor is composed on 3 elements:</p>
<ul>
<li>a set of inputs,</li>
<li>a set of outputs,</li>
<li>a client.</li>
</ul>
<p>Both outputs and inputs are optional but an actor must have at least either one input or one output.
Inputs and outputs may be sampled at a different rate, but the rate must be the same for all inputs and for all outputs.</p>
<p><img src="gmt-actor-model/actors/actor-model.svg" alt="Gmt actors" /></p>
<p>An actor runs within its own thread independently of other actors and perform 3 functions:</p>
<ol>
<li>collect and read inputs into the client,</li>
<li>update the state of the client,</li>
<li>write and distribute the outputs from the client to other actors.</li>
</ol>
<p>These 3 functions are excuted sequentially within a loop.</p>
<p>A client must comply with the definition of the actor interface.
The interface consists in 3 traits: <code>Update</code>, <code>Read</code> and <code>Write</code>.
A client must:</p>
<ul>
<li>implement the <code>Update</code> trait,</li>
<li>have an implementation of the <code>Read</code> trait for each input,</li>
<li>have an implementation of the <code>Write</code> trait for each output.</li>
</ul>
<p>Actor inputs and outputs are given a unique type, usually an empty Enum.
Each input and output must implement the <code>UniqueIdentifier</code> trait which associated type <code>DataType</code> is set to the primitive type of the client data.</p>
<p>As an example, lets write an interface for a client which task is to multiply an integer by e.
Lets define</p>
<ul>
<li>the client:</li>
</ul>
<pre><code class="language-rust no_run noplayground">#[derive(Default)]
struct Client {
   data: i32,
}</code></pre>
<ul>
<li>the input <code>In</code>:</li>
</ul>
<pre><code class="language-rust no_run noplayground">#[derive(UID)]
#[uid(data = &quot;i32&quot;)]
enum In {}</code></pre>
<ul>
<li>the output <code>Out</code>:</li>
</ul>
<pre><code class="language-rust no_run noplayground">#[derive(UID)]
#[uid(data = &quot;f32&quot;)]
enum Out {}</code></pre>
<p>Each input and output is given a unique type (here an empty <code>Enum</code>) that implements the <code>UniqueIdentifier</code> trait with the derive macro <code>UID</code>. 
The input/ouput primitive types (<code>i32</code> for the input and <code>f32</code> for the ouput) are affected to the associated type <code>DataType</code> of the <code>UniqueIdentifier</code> traits.</p>
<p>And now lets build the interface:</p>
<ul>
<li>update is empty, this simple task can be done at the output</li>
</ul>
<pre><code class="language-rust no_run noplayground">impl Update for Client {}</code></pre>
<ul>
<li>read input</li>
</ul>
<pre><code class="language-rust no_run noplayground">impl Read&lt;In&gt; for Client {
    fn read(&amp;mut self, data: Arc&lt;Data&lt;In&gt;&gt;) {
        self.data = **data;
    }
}
</code></pre>
<ul>
<li>write output</li>
</ul>
<pre><code class="language-rust no_run noplayground">impl Write&lt;Out&gt; for Client {
    fn write(&amp;mut self) -&gt; Option&lt;Arc&lt;Data&lt;Out&gt;&gt;&gt; {
        Some(Arc::new(Data::new(self.data as f32 * std::f32::consts::E)))
    }
}</code></pre>
<p>Actors exchange their clients data that is contained inside the structure <code>Data</code>. 
The type of the client data can be anything as long as the input that receives it or the output that sends it, implements the <code>UniqueIdentifier</code> trait.</p>
<p>Once the actor to client interface has been written, the client can then be used to build an actor.
Here is the signature of the <code>Actor</code> type:</p>
<pre><code class="language-rust no_run noplayground">struct Actor&lt;C, const NI: usize = 1, const NO: usize = 1&gt; where C: Update</code></pre>
<p>An actor takes 3 generic type parameters: </p>
<ul>
<li><code>C</code>: the type of the client,</li>
<li><code>NI</code>: the sampling rate of the inputs,</li>
<li><code>NO</code>: the sampling rate of the outputs.</li>
</ul>
<p>Sampling rates are given as ratio between the simulation sampling frequency and the actor inputs or outputs sampling frequency.
The where clause required that the client implements the <code>Update</code> trait, meaning that anything can be an actor's client as long as it implements the <code>Update</code> trait.</p>
<p>Actors implements the <a href="https://doc.rust-lang.org/std/convert/trait.From.html">From</a> trait for any type that implements the <code>Update</code> trait. 
As a consequence, a client can be converted into an actor with:</p>
<pre><code class="language-rust no_run noplayground">let actor = Actor::&lt;Client,1,1&gt;::from(client);</code></pre>
<p>When using the default value (1) for the inputs and outputs rate, they can be omitted:</p>
<pre><code class="language-rust no_run noplayground">let actor = Actor::&lt;Client&gt;::from(client);</code></pre>
<p>In that case, the compiler is also able to infer the client type:</p>
<pre><code class="language-rust no_run noplayground">let actor = Actor::&lt;_&gt;::from(client);</code></pre>
<p>or we can use the <a href="https://doc.rust-lang.org/std/convert/trait.Into.html">Into</a> syntax:</p>
<pre><code class="language-rust no_run noplayground">let actor: Actor::&lt;_&gt; = client.into();</code></pre>
<p>An actor with no inputs must set <code>NI</code> to 0 or use the type alias <code>Initiator</code> defined as <code>Initiator&lt;C, const NO: usize = 1&gt; = Actor&lt;C, 0, NO&gt;</code>:</p>
<pre><code class="language-rust no_run noplayground">let no_input_actor = Initiator::&lt;_&gt;::from(client);</code></pre>
<p>An actor with no outputs must set <code>NO</code> to 0 or use the type alias <code>Terminator</code> defined as <code>Terminator&lt;C, const NI: usize = 1&gt; = Actor&lt;C, NI, 0&gt;</code>:</p>
<pre><code class="language-rust no_run noplayground">let no_output_actor = Terminator::&lt;_&gt;::from(client);</code></pre>
<p>The conversion methods <code>from</code> and <code>into</code> consume their arguments meaning that the client is no longer available once the actor has been created.
This is not always desirable, instead the <code>new</code> method of  <code>Actor</code> can be used to pass a reference to the client into an actor.</p>
<p>It is worth noting that all the inputs and outputs of an actor will also be given a copy of the reference to the client in order to pass data to it and to get data from it.
And because an actor performs many of its own tasks asynchronously, a client must first be wrapped into the thread-safe smart pointers <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Arc</a> and <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html">Mutex</a> like so</p>
<pre><code class="language-rust no_run noplayground">let thread_safe_client = Arc::new(Mutex::new(client));</code></pre>
<p>followed by the actor declaration</p>
<pre><code class="language-rust no_run noplayground">let actor = Actor::new(thread_safe_client.clone());</code></pre>
<p>Note that all types that implements the <code>Update</code> trait can be converted into a thread safe type with</p>
<pre><code class="language-rust no_run noplayground">let thread_safe_client = client.into_arcx();</code></pre>
<p>A unique name can be given to an actor. 
The name will be use to identify the actor's client in the model flowchart.
The actor's name (here &quot;aleph&quot;) can be set either like this:</p>
<pre><code class="language-rust no_run noplayground">let actor = Actor::&lt;_&gt;::from((client, &quot;aleph&quot;));</code></pre>
<p>or like this</p>
<pre><code class="language-rust no_run noplayground">let actor: Actor::&lt;_&gt; = (client, &quot;aleph&quot;).into();</code></pre>
<p>or even like this</p>
<pre><code class="language-rust no_run noplayground">let actor = Actor::new(thread_safe_client.clone()).name(&quot;aleph&quot;);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data"><a class="header" href="#data">Data</a></h1>
<p>The essential role of actors is to pass data through channels from one client to another client by the mean of their respective actor<code>Read/Write</code> interfaces .
The data is encapsulated into a tuple structure <code>Data&lt;U&gt;</code>:</p>
<pre><code class="language-rust no_run noplayground">pub struct Data&lt;U: UniqueIdentifier&gt;(&lt;U as UniqueIdentifier&gt;::DataType, PhantomData&lt;U&gt;);</code></pre>
<p>Each container <code>Data&lt;U&gt;</code> is uniquely defined with a type parameter <code>U</code>,
the trait bound on <code>U</code> means that <code>U</code> must implement the <code>UniqueIdentifier</code> trait and the actual type of the data 
that is moved around is given by the trait associated type <code>UniqueIdentifier::DataType</code>.</p>
<p>As an example, lets define 2 clients <code>ClientA</code> and <code>ClientB</code> and a double precision vector <code>Vec&lt;f64&gt;</code> that must be transferred from <code>ClientA</code> to <code>ClientB</code>.
To do so, one needs </p>
<ul>
<li>first to define <code>U</code>:</li>
</ul>
<pre><code class="language-rust no_run noplayground">pub enum A2B {}</code></pre>
<p>here <code>U</code> is an empty enum. <code>U</code> can be of any type however empty enums are very efficient in terms of zero-cost abstraction as they entirely vanished after compilation.</p>
<ul>
<li>then to implement the trait <code>UniqueIdentifier</code>:</li>
</ul>
<pre><code class="language-rust no_run noplayground">impl UniqueIdentifer for A2B {
  type DataType = Vec&lt;f64&gt;;
}
</code></pre>
<p>This is where the actual type of the data to be transferred, is defined.</p>
<p>Note that there is a derive macro <code>UID</code> that implements the <code>UniqueIdentifier</code> trait on any type that the derive attribute is applied to, so we could have written instead:</p>
<pre><code class="language-rust no_run noplayground">#[derive(UID)]
#[uid(data=&quot;Vec&lt;f64&gt;&quot;)]
pub enum A2B {}</code></pre>
<p>The derive macro uses <code>Vec&lt;f64&gt;</code> as the default type for <code>DataType</code>, so an even simpler declaration is</p>
<pre><code class="language-rust no_run noplayground">#[derive(UID)]
pub enum A2B {}</code></pre>
<p>After that the <code>Read</code> and <code>Write</code> traits are implemented:</p>
<ul>
<li>Write</li>
</ul>
<pre><code class="language-rust no_run noplayground">impl Write&lt;A2B&gt; for ClientA {
   fn write(&amp;mut self) -&gt; Option&lt;Arc&lt;Data&lt;A2B&gt;&gt;&gt; { ... }
}</code></pre>
<ul>
<li>Read</li>
</ul>
<pre><code class="language-rust no_run noplayground">impl Read&lt;A2B&gt; {
   fn read(&amp;mut self, data: Arc&lt;Data&lt;A2B&gt;&gt;) { ... }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="model"><a class="header" href="#model">Model</a></h1>
<p>A model is a network of clients connected to each other by pairs of output/input.
The actor/client interfaces specify the tasks that are going to be executed and the topology of the network defines the order in which the tasks are executed.</p>
<p>A pair of output/input defines a unique <a href="https://docs.rs/flume/latest/flume/">channel</a>  with a sender and a receiver.
The sender is given to the output and the receiver to the input. </p>
<p>Each actor performs the following task sequentially in a never ending inner loop and asynchronously with respect to the other actors :</p>
<ol>
<li>if any inputs, receive inputs &amp; invoke client <code>gmt_dos_actors::io::Read</code> trait implementation on each input,</li>
<li>update client state with the client <code>gmt_dos_actors::io::Update</code> trait implementation,</li>
<li>if any outputs, invoke the client <code>gmt_dos_actors::io::Write</code> trait implementation on each output &amp; send outputs.</li>
</ol>
<p>The default behavior of an actor is to pause the inner loop both until all the inputs have been received and until all the outputs have been received by other actors.</p>
<p><img src="gmt-actor-model/model/model.svg" alt="Model" /></p>
<p>In the model above, the network topology imposes the following sequence of events (from top to bottom):</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right"></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody>
<tr><td style="text-align: right">1</td><td><code>Update</code></td><td>-</td><td>-</td><td>-</td></tr>
<tr><td style="text-align: right">2</td><td><code>Write::&lt;AB,ABC&gt;</code></td><td>-</td><td>-</td><td>-</td></tr>
<tr><td style="text-align: right">3</td><td>-</td><td><code>Read::&lt;AB,ABC&gt;</code></td><td><code>Read::&lt;ABC&gt;</code></td><td>-</td></tr>
<tr><td style="text-align: right">4</td><td><code>Update</code></td><td>-</td><td><code>Update</code></td><td>-</td></tr>
<tr><td style="text-align: right">5</td><td><code>Write::&lt;AB,ABC&gt;</code></td><td>-</td><td><code>Write::&lt;CB,CD&gt;</code></td><td>-</td></tr>
<tr><td style="text-align: right">6</td><td>-</td><td><code>Read::&lt;CB&gt;</code></td><td>-</td><td><code>Read::&lt;CD&gt;</code></td></tr>
<tr><td style="text-align: right">7</td><td>-</td><td><code>Update</code></td><td><code>Read::&lt;ABC&gt;</code></td><td>-</td></tr>
<tr><td style="text-align: right">8</td><td>-</td><td><code>Write::&lt;BD1,BD2&gt;</code></td><td><code>Update</code></td><td>-</td></tr>
<tr><td style="text-align: right">9</td><td>-</td><td>-</td><td><code>Write::&lt;CB,CD&gt;</code></td><td><code>Read::&lt;BD1,BD2&gt;</code></td></tr>
<tr><td style="text-align: right">10</td><td>-</td><td><code>Read::&lt;AB,ABC,CB&gt;</code></td><td>-</td><td><code>Update</code></td></tr>
<tr><td style="text-align: right">11</td><td><code>Update</code></td><td><code>Update</code></td><td>-</td><td><code>Read::&lt;CD&gt;</code></td></tr>
<tr><td style="text-align: right">12</td><td>...</td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>Note that events in the same row may occur simultaneously thanks to the asynchronous nature of the actors.</p>
<p>Laying out the network consists in building actors outputs and relaying them to other actors inputs.
A pair of output and input must meet the following requirements:</p>
<ul>
<li>the client of the output actor must implement the trait <code>gmt_dos_actors::io::Write&lt;I&gt;</code></li>
<li>the client of the input actor must implement the trait <code>gmt_dos_actors::io::Read&lt;O&gt;</code></li>
<li><code>I</code> and <code>O</code> must be of the same type i.e. <code>I=O</code></li>
<li>the ouput rate <code>NO</code> must be equal to the input rate <code>NI</code> (<code>NO=NI</code>)</li>
</ul>
<p>A model will not compile in any of the above requirements is not met.</p>
<p>For client <code>A</code> that gives:</p>
<pre><code class="language-rust no_run noplayground">A.add_output().build::&lt;AB&gt;().into_input(&amp;mut B);
A.add_output().multiplex(2).build::&lt;ABC&gt;()
   .into_input(&amp;mut B)
   .into_input(&amp;mut C);</code></pre>
<p>As illustrated above, an output can be multiplexed and sent to multiple inputs.</p>
<p>Then for <code>B</code>:</p>
<pre><code class="language-rust no_run noplayground">B.add_output().build::&lt;BD1&gt;().into_input(&amp;mut D);
B.add_output().build::&lt;BD2&gt;().into_input(&amp;mut D);</code></pre>
<p>and <code>C</code> :</p>
<pre><code class="language-rust no_run noplayground">C.add_output().build::&lt;CB&gt;().into_input(&amp;mut B);
C.add_output().build::&lt;CD&gt;().into_input(&amp;mut D);</code></pre>
<p>Per default, an actor inner loop is blocked until all its outputs have been read by the associated inputs as a guarantee that the data has been effectively received.</p>
<p>This is not always necessary, particulary for a client that acts as a data sink like <code>D</code>.
The links to <code>D</code> can be rewritten:</p>
<pre><code class="language-rust no_run noplayground">B.add_output().unbounded().build::&lt;BD1&gt;().into_input(&amp;mut D);
B.add_output().unbounded().build::&lt;BD2&gt;().into_input(&amp;mut D);
C.add_output().unbounded().build::&lt;CD&gt;().into_input(&amp;mut D);</code></pre>
<p>and the outputs <code>BD1</code>, <code>BD2</code> and <code>CD</code> won't block their actors inner loop anymore.</p>
<p>Once all the connections have been set-up, we can assemble the actors into a model:</p>
<pre><code class="language-rust no_run noplayground">let mut model = Model::new(vec![Box::new(A),Box::new(B),Box::new(C),Box::new(D)]);</code></pre>
<p>check the model for errors, run it and wait for it to finish:</p>
<pre><code class="language-rust no_run noplayground">model.check()?.run().await?;</code></pre>
<p>Note that the <code>run</code> method cannot be invoked on an unchecked model.
The methods that can be called upon <a href="https://docs.rs/gmt_dos-actors/latest/gmt_dos_actors/model/struct.Model.html"><code>Model</code></a> depend on the value of the <code>Model</code> <code>State</code> generic type parameter.
Some method performs a state transition giving access to other methods.</p>
<p>The model <code>State</code> table shows from which state a <code>Model</code> method is called and in which state the model is transitioned to:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>From</th><th>To</th></tr></thead><tbody>
<tr><td><code>Model::new</code></td><td><code>Unknown</code></td><td><code>Unknown</code></td></tr>
<tr><td><code>Model::check</code></td><td><code>Unknown</code></td><td><code>Ready</code></td></tr>
<tr><td><code>Model::run</code></td><td><code>Ready</code></td><td><code>Running</code></td></tr>
<tr><td><code>Model::await</code></td><td><code>Running</code></td><td><code>Completed</code></td></tr>
<tr><td><code>Model::name</code></td><td><code>Unknown</code></td><td><code>Unknown</code></td></tr>
<tr><td><code>Model::add</code></td><td><code>Unknown</code></td><td><code>Unknown</code></td></tr>
<tr><td><code>Model::flowchart</code></td><td><code>Unknown</code></td><td><code>Unknown</code></td></tr>
<tr><td><code>Model::flowchart</code></td><td><code>Ready</code></td><td><code>Ready</code></td></tr>
</tbody></table>
</div>
<p>A flow chart of the model can be obtained with the <code>flowchart</code> method.
Each client is identified by either its type or the actor's name if one was given.
Combining all the <code>Model</code> methods in a single call gives:</p>
<pre><code class="language-rust no_run noplayground">Model::new(vec![Box::new(A),
               Box::new(B),
               Box::new(C),
               Box::new(D)])
   .flowchart()
   .check()?
   .run()
   .await?;</code></pre>
<p>The flowchart is written to the file <code>integrated_model.dot.svg</code>.</p>
<p>The boilerplate code used for model declaration: </p>
<pre><code class="language-rust no_run noplayground">Model::new(vec![Box::new(...),vec![Box::new(...),...])</code></pre>
<p>can be advantageously replaced with the Rust macro <code>model!</code>, e.g.</p>
<pre><code class="language-rust no_run noplayground">model!(A,B,C,D)
   .flowchart()
   .check()?
   .run()
   .await?;</code></pre>
<p>When an output detects that the data the client has written to its buffer is <code>None</code>, it closes the channel it belongs to and return an error to the actor that forces the actor to shut down.</p>
<p>When an actor shuts down its inputs and outputs close the channels they are part of.
A closed channel also generates an error that is caught by the actors at both end of the channel and forces these actors to also shut down and so, by a domino effect, all the actors are terminated and the model gracefully comes to an end.</p>
<h2 id="working-example"><a class="header" href="#working-example">Working example</a></h2>
<p>Building upon the example in the previous section, lets add 2 more clients:</p>
<ul>
<li>a random generator</li>
</ul>
<pre><code class="language-rust no_run noplayground">struct RandGen {
    data: Vec&lt;i32&gt;,
}
impl RandGen {
    pub fn new(n_sample: usize) -&gt; Self {
        let mut data = vec![0i32; n_sample];
        let mut rng = WyRand::new();
        rng.fill(&amp;mut data);
        Self { data }
    }
}
impl Update for RandGen {}
impl Write&lt;In&gt; for RandGen {
    fn write(&amp;mut self) -&gt; Option&lt;Arc&lt;Data&lt;In&gt;&gt;&gt; {
        self.data.pop().map(|val| Arc::new(Data::new(val)))
    }
}</code></pre>
<ul>
<li>a data logger</li>
</ul>
<pre><code class="language-rust no_run noplayground">#[derive(Default)]
struct DataLogger {
    data: Vec&lt;f32&gt;,
}
impl Update for DataLogger {}
impl Read&lt;Out&gt; for DataLogger {
    fn read(&amp;mut self, data: Arc&lt;Data&lt;Out&gt;&gt;) {
        self.data.push(**data);
    }
}</code></pre>
<p>With all the clients defined with an actor/client interface, the actors are instanciated with</p>
<pre><code class="language-rust no_run noplayground">    let mut source = Initiator::&lt;_&gt;::from(RandGen::new(1_000_000));
    let mut filter = Actor::&lt;_&gt;::from(Client::default());
    let mut log = Terminator::&lt;_&gt;::from(DataLogger::default());</code></pre>
<p>Each actor requires 3 generic type parameters: the client type and 2 constants: the inputs and outputs sampling rates.
The inputs rate is zero if the actor has no inputs and the outputs rate is zero if the actor has no outputs.
The default sampling rate for inputs and outputs is 1.</p>
<p>The next step is to build the network. The links between actors are established by successively creating channels between an actor output and the input of another actor, both the output and the input must have been given the same type and the same sampling rate. </p>
<pre><code class="language-rust no_run noplayground">    source
        .add_output()
        .build::&lt;In&gt;()
        .into_input(&amp;mut filter)?;
    filter
        .add_output()
        .unbounded()
        .build::&lt;Out&gt;()
        .into_input(&amp;mut log)?;</code></pre>
<p>Now the model can be assembled, charted, checked for errors and run:</p>
<pre><code class="language-rust no_run noplayground">    model!(source, filter, log)
        .flowchart()
        .check()?
        .run()
        .await?;</code></pre>
<p><img src="gmt-actor-model/model/integrated_model.dot.svg" alt="Integrated Model" /></p>
<p>The model stop itself when the data from the <code>RandGen</code> client is exhausted.</p>
<p>By setting a <a href="https://docs.rs/log/">logger</a> at the begining of the main application, insight into the behavior of the model can be gathered.
For example, setting the <a href="https://docs.rs/env_logger/">env_logger</a> crate with </p>
<pre><code class="language-rust no_run noplayground">    env_logger::builder()
        .format_timestamp(None)
        .format_target(false)
        .init();</code></pre>
<p>and running the application with the <code>RUST_LOG</code> environment variable:</p>
<pre><code>RUST_LOG=warn cargo run ... 
</code></pre>
<p>outputs the following:</p>
<p><img src="gmt-actor-model/model/model_warn.png" alt="Warning" /></p>
<p>Setting  <code>RUST_LOG</code> to <code>info</code> instead gives</p>
<pre><code>RUST_LOG=info cargo run ... 
</code></pre>
<p><img src="gmt-actor-model/model/model_info.png" alt="Warning" /></p>
<p>and with </p>
<pre><code>RUST_LOG=debug cargo run ... 
</code></pre>
<p><img src="gmt-actor-model/model/model_debug.png" alt="Warning" /></p>
<p>Debug information is displayed only for application run in debug mode.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clients"><a class="header" href="#clients">Clients</a></h1>
<p>The crate <code>gmt_dos-actors</code> includes a library of clients for signals generation and signal processing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signals--logger"><a class="header" href="#signals--logger">Signals &amp; Logger</a></h1>
<p>In the following, we will introduce the <a href="https://docs.rs/gmt_dos-actors/latest/gmt_dos_actors/clients/struct.Signals.html"><code>signals</code></a>, <a href="https://docs.rs/gmt_dos-actors/latest/gmt_dos_actors/clients/struct.Source.html"><code>Source</code></a>, <a href="https://docs.rs/gmt_dos-actors/latest/gmt_dos_actors/clients/struct.Logging.html"><code>Logging</code></a> and <a href="file:///media/rconan/projects/target/doc/gmt_dos_actors/clients/struct.Timer.html"><code>Timer</code></a> clients.</p>
<p>Both <a href="https://docs.rs/gmt_dos-actors/latest/gmt_dos_actors/clients/struct.Signals.html"><code>Signals</code></a> and <a href="https://docs.rs/gmt_dos-actors/latest/gmt_dos_actors/clients/struct.Source.html"><code>Source</code></a> are signals generators and
both are multi-channels with a single multiplexed output.</p>
<p>The signals generated with <code>Signals</code> are either a constant, a sinusoide, a ramp, a sinusoide or white-noise. For example, here is an <code>Actor</code> which client is a 2 channels <code>Signals</code>, each channel with the same sinusoide but out-of-phase:</p>
<pre><code class="language-rust no_run noplayground">        let n_step = 9;
        let mut signals: Initiator&lt;_&gt; = Signals::new(2, n_step)
            .channel(
                0,
                Signal::Sinusoid {
                    amplitude: 1f64,
                    sampling_frequency_hz: (n_step - 1) as f64,
                    frequency_hz: 1f64,
                    phase_s: 0f64,
                },
            )
            .channel(
                1,
                Signal::Sinusoid {
                    amplitude: 1f64,
                    sampling_frequency_hz: (n_step - 1) as f64,
                    frequency_hz: 1f64,
                    phase_s: 0.5f64,
                },
            )
            .into();</code></pre>
<p><code>Source</code> signals are user provided, the multiplexed channels are given as a single flatten vector argument:</p>
<pre><code class="language-rust no_run noplayground">        let mut source: Initiator&lt;_&gt; = Source::new(
            (0..n_step)
                .flat_map(|x| vec![x as f64, (n_step - x - 1) as f64]) // 2 channels
                .collect(),
            2,
        )
        .into();</code></pre>
<p>The <a href="https://docs.rs/gmt_dos-actors/latest/gmt_dos_actors/clients/struct.Logging.html"><code>Logging</code></a> client simply accumulates all its inputs into a single vector. <code>Logging</code> requires all inputs signals to be of the same type. 
An actor for a <code>Logging</code> client with entries for both the <code>Signals</code> and <code>Source</code> clients is declared with</p>
<pre><code class="language-rust no_run noplayground">        let logging = Logging::&lt;f64&gt;::new(2).into_arcx();
        let mut logger = Terminator::&lt;_&gt;::new(logging.clone());</code></pre>
<p>Building a <code>Model</code> out of the 3 actors:</p>
<pre><code class="language-rust no_run noplayground">#[derive(UID)]
enum Sinusoides {}
#[derive(UID)]
enum UpDown {}

        signals
            .add_output()
            .unbounded()
            .build::&lt;Sinusoides&gt;()
            .into_input(&amp;mut logger)?;
        source
            .add_output()
            .unbounded()
            .build::&lt;UpDown&gt;()
            .into_input(&amp;mut logger)?;

        model!(signals, source, logger)
            .name(&quot;signals-logger&quot;)
            .flowchart()
            .check()?
            .run()
            .await?;</code></pre>
<p>gives (the dashed lines representing the &quot;unbounded&quot; inputs):</p>
<p><img src="gmt-actor-model/clients/sig-log/signals-logger.dot.svg" alt="Signals &amp; Loggers Model" /></p>
<p>and the following data has been logged:</p>
<pre><code class="language-rust no_run noplayground">        println!(&quot;Logs:&quot;);
        (*logging.lock().await)
            .chunks()
            .enumerate()
            .for_each(|(i, x)| println!(&quot;{}: {:+.3?}&quot;, i, x));</code></pre>
<p><img src="gmt-actor-model/clients/sig-log/sig-log_out1.png" alt="Signals &amp; Loggers Model output" /></p>
<p>The <a href="file:///media/rconan/projects/target/doc/gmt_dos_actors/clients/struct.Timer.html"><code>Timer</code></a> client does not generate a new signal instead it adds a beat to the model and takes as input argument a number of beat. 
A <code>Model</code> with a timer will terminate after the last beat.
Lets update the previous <code>Model</code> with a timer which number of beat is half the number of sample that the signals clients are set to generate:</p>
<pre><code class="language-rust no_run noplayground">        let mut timer: Initiator&lt;_&gt; = Timer::new(n_step / 2).into();</code></pre>
<p>The <code>signals</code> and <code>source</code> clients are modified to accept the <code>timer</code> input:</p>
<pre><code class="language-rust no_run noplayground">        let mut signals: Actor&lt;_&gt; = Signals::new(2, n_step)
            .channel(
                0,
                Signal::Sinusoid {
                    amplitude: 1f64,
                    sampling_frequency_hz: (n_step - 1) as f64,
                    frequency_hz: 1f64,
                    phase_s: 0f64,
                },
            )
            .channel(
                1,
                Signal::Sinusoid {
                    amplitude: 1f64,
                    sampling_frequency_hz: (n_step - 1) as f64,
                    frequency_hz: 1f64,
                    phase_s: 0.5f64,
                },
            )
            .into();

        let mut source: Actor&lt;_&gt; = Source::new(
            (0..n_step)
                .flat_map(|x| vec![x as f64, (n_step - x - 1) as f64])
                .collect(),
            2,
        )
        .into();</code></pre>
<p><code>logger</code> remains the same and the timer is connected to both <code>signals</code> and <code>source</code>:</p>
<pre><code class="language-rust no_run noplayground">        timer
            .add_output()
            .multiplex(2)
            .build::&lt;Tick&gt;()
            .into_input(&amp;mut signals)
            .into_input(&amp;mut source)?;
        signals
            .add_output()
            .unbounded()
            .build::&lt;Sinusoides&gt;()
            .into_input(&amp;mut logger)?;
        source
            .add_output()
            .unbounded()
            .build::&lt;UpDown&gt;()
            .into_input(&amp;mut logger)?;</code></pre>
<p>Note that for a client to allow <code>Timer</code> as input, it must implement the <code>TimerMarker</code> trait.
The new model looks like this:</p>
<pre><code class="language-rust no_run noplayground">        model!(timer, signals, source, logger)
            .name(&quot;signals-logger-trunc&quot;)
            .flowchart()
            .check()?
            .run()
            .await?;</code></pre>
<p><img src="gmt-actor-model/clients/sig-log/signals-logger-trunc.dot.svg" alt="Signals &amp; Loggers Model" /></p>
<p>and the following data has been logged:</p>
<pre><code class="language-rust no_run noplayground">        println!(&quot;Logs:&quot;);
        (*logging.lock().await)
            .chunks()
            .enumerate()
            .for_each(|(i, x)| println!(&quot;{}: {:+.3?}&quot;, i, x));</code></pre>
<p><img src="gmt-actor-model/clients/sig-log/sig-log_out2.png" alt="Signals &amp; Loggers Model output" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="feedback-system"><a class="header" href="#feedback-system">Feedback System</a></h1>
<p>A feedback system is a system with a feedback loop:</p>
<p><img src="gmt-actor-model/clients/feedback/feedback.dot.svg" alt="Feedback system" /></p>
<p>Such a system with a direct feedthrough from C to B is also known as an algebraic loop.
It is a singular system as shown with the sequence of events:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right"></th><th>A</th><th>B</th><th>C</th></tr></thead><tbody>
<tr><td style="text-align: right">1</td><td><code>Update</code></td><td>-</td><td>-</td></tr>
<tr><td style="text-align: right">2</td><td><code>Write::&lt;U&gt;</code></td><td>-</td><td>-</td></tr>
<tr><td style="text-align: right">3</td><td>-</td><td><code>Read::&lt;U&gt;</code></td><td>-</td></tr>
</tbody></table>
</div>
<p>After step 3, the system cannot progress: B is waiting for  Y from C before sendind E to C, while at the same time, C is waiting for E from B before sending Y to B.</p>
<p>In order to resolve the conflict, we can bootstrap the system but having C sending a default value for Y at the start of the simulation:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right"></th><th>A</th><th>B</th><th>C</th></tr></thead><tbody>
<tr><td style="text-align: right">1</td><td><code>Update</code></td><td>-</td><td><code>Write::&lt;Y&gt;</code></td></tr>
<tr><td style="text-align: right">2</td><td><code>Write::&lt;U&gt;</code></td><td>-</td><td>-</td></tr>
<tr><td style="text-align: right">3</td><td>-</td><td><code>Read::&lt;U,Y&gt;</code></td><td>-</td></tr>
<tr><td style="text-align: right">4</td><td><code>Update</code></td><td><code>Update</code></td><td>-</td></tr>
<tr><td style="text-align: right">5</td><td><code>Write::&lt;U&gt;</code></td><td><code>Write::&lt;E&gt;</code></td><td>-</td></tr>
<tr><td style="text-align: right">6</td><td>-</td><td>-</td><td><code>Read::&lt;E&gt;</code></td></tr>
<tr><td style="text-align: right">7</td><td>-</td><td><code>Read::&lt;U&gt;</code></td><td><code>Update</code></td></tr>
<tr><td style="text-align: right">8</td><td><code>Update</code></td><td>-</td><td><code>Write::&lt;Y&gt;</code></td></tr>
<tr><td style="text-align: right">9</td><td><code>Write::&lt;U&gt;</code></td><td><code>Read::&lt;Y&gt;</code></td><td></td></tr>
<tr><td style="text-align: right">10</td><td>-</td><td><code>Update</code></td><td>-</td></tr>
<tr><td style="text-align: right">11</td><td>...</td><td></td><td></td></tr>
</tbody></table>
</div>
<p><code>gmt_dos-actors</code> implements such bootstrapping method for feedback system like the kind of system with an integral controller.</p>
<p><a href="https://docs.rs/gmt_dos-actors/latest/gmt_dos_actors/clients/struct.Integrator.html"><code>Integrator</code></a> is the client that performs the functions of an integral controller.
It continuously integrates the negative of the input (weighted by the gain of the controller) and returns the integral. </p>
<p>An actor for a scalar integrator with a gain of 0.5 is declared with</p>
<pre><code class="language-rust no_run noplayground">    let mut integrator: Actor&lt;_&gt; = Integrator::new(1).gain(0.5).into();</code></pre>
<p>Lets add a constant signal and a logger to the model:</p>
<pre><code class="language-rust no_run noplayground">    let mut signal: Initiator&lt;_&gt; = Signals::new(1, n_step)
        .channel(0, Signal::Constant(1f64))
        .into();
    let logging = Logging::&lt;f64&gt;::new(3).into_arcx();
    let mut logger = Terminator::&lt;_&gt;::new(logging.clone());</code></pre>
<p>The client of the last actor to be added to the model, sums the signal and the feedback from the integral controller:</p>
<pre><code class="language-rust no_run noplayground">    let mut sum: Actor&lt;_&gt; = (Sum::default(), &quot;+&quot;).into();</code></pre>
<p>Lets define the types for inputs and outputs:</p>
<pre><code class="language-rust no_run noplayground">#[derive(UID)]
enum U {}
#[derive(UID)]
enum Y {}
#[derive(UID)]
enum E {}</code></pre>
<p>The connections are defined with, for the feedthrough:</p>
<pre><code class="language-rust no_run noplayground">    signal
        .add_output()
        .multiplex(2)
        .build::&lt;U&gt;()
        .into_input(&amp;mut sum)
        .into_input(&amp;mut logger)?;
    sum.add_output()
        .multiplex(2)
        .build::&lt;E&gt;()
        .into_input(&amp;mut integrator)
        .into_input(&amp;mut logger)?;</code></pre>
<p>and for the feedback with the bootstrapping of <code>Y</code>:</p>
<pre><code class="language-rust no_run noplayground">    integrator
        .add_output()
        .multiplex(2)
        .bootstrap()
        .build::&lt;Y&gt;()
        .into_input(&amp;mut sum)
        .into_input(&amp;mut logger)?;</code></pre>
<p>The model is:</p>
<pre><code class="language-rust no_run noplayground">    model!(signal, sum, integrator, logger)
        .name(&quot;feedback-model&quot;)
        .flowchart()
        .check()?
        .run()
        .await?;</code></pre>
<p><img src="gmt-actor-model/clients/feedback/feedback-model.dot.svg" alt="Feedback model" /></p>
<p>Note the bolder line for the <code>Y</code> output (this is how the bootstrapped outputs are always drawn).</p>
<p>The logged data is</p>
<pre><code class="language-rust no_run noplayground">    println!(&quot;Logs:&quot;);
    println!(&quot;    :     U       E       Y&quot;);
    (*logging.lock().await)
        .chunks()
        .enumerate()
        .take(20)
        .for_each(|(i, x)| println!(&quot;{:4}: {:+.3?}&quot;, i, x));</code></pre>
<p><img src="gmt-actor-model/clients/feedback/feedback_out.png" alt="Feedback logs" /></p>
<h4 id="implementation-of-the-sum-client"><a class="header" href="#implementation-of-the-sum-client">Implementation of the <code>Sum</code> client:</a></h4>
<pre><code class="language-rust no_run noplayground">pub struct Sum {
    left: Arc&lt;Data&lt;U&gt;&gt;,
    right: Arc&lt;Data&lt;Y&gt;&gt;,
}
impl Default for Sum {
    fn default() -&gt; Self {
        Self {
            left: Arc::new(Data::new(vec![])),
            right: Arc::new(Data::new(vec![])),
        }
    }
}
impl Update for Sum {}
impl Read&lt;U&gt; for Sum {
    fn read(&amp;mut self, data: Arc&lt;Data&lt;U&gt;&gt;) {
        self.left = data.clone();
    }
}
impl Read&lt;Y&gt; for Sum {
    fn read(&amp;mut self, data: Arc&lt;Data&lt;Y&gt;&gt;) {
        self.right = data.clone();
    }
}
impl Write&lt;E&gt; for Sum {
    fn write(&amp;mut self) -&gt; Option&lt;Arc&lt;Data&lt;E&gt;&gt;&gt; {
        Some(Arc::new(Data::new(
            self.left
                .iter()
                .zip(self.right.iter())
                .map(|(l, r)| l + r)
                .collect(),
        )))
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multirate-system"><a class="header" href="#multirate-system">Multirate System</a></h1>
<p>A multirate system mixes signals sampled at different rates.
The flowchart below is a depiction of such a system implemented with <code>gmt_dos-actors</code> where the sample rates of the inputs and outputs (IO) are color coded according to the following table:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">green</th><th style="text-align: center">orange</th><th style="text-align: center">purple</th></tr></thead><tbody>
<tr><td style="text-align: center">1</td><td style="text-align: center">1/4</td><td style="text-align: center">1/2</td></tr>
</tbody></table>
</div>
<p><img src="gmt-actor-model/clients/multirate/multirate-model.dot.svg" alt="Multirate model" /></p>
<p>The purple IO and orange IO are, respectively, 1/2 and 1/4 the sampling rate of the green IO as show in the outputs record:</p>
<p><img src="gmt-actor-model/clients/multirate/multirate_out.png" alt="Multirate logs" /></p>
<p>Any actor with different inputs (<code>NI</code>) and outputs (<code>NO</code>) sampling rates implements a rate transition.
<code>NI</code> and <code>NO</code> are given as ratios with respect to the highest sampling rate, e.g. for the green IO: <code>NI=NO=1</code> , for the orange IO: <code>NI=NO=4</code> and for the purple IO: <code>NI=NO=2</code>.
If <code>NO&gt;NI</code>, the outputs are downsampled, meaning that there is a set of outputs only every <code>NO/NI</code> samples.
If <code>NI&gt;NO</code>, the outputs are upsampled with a zero-order hold, meaning that the outputs are repeated for <code>NI/NO</code> samples.</p>
<p>In any case, downsampling and upsampling,
the <code>Update</code>method of the actor's client is invoked at the input rate.</p>
<p>The <code>gmt_dos-actors</code> implementation of the multirate system above starts by setting the downsampling and upsampling rates:</p>
<pre><code class="language-rust no_run noplayground">const UPRATE: usize = 2;
const DOWNRATE: usize = 4;</code></pre>
<p>The input signal is a ramp (a * i + b) starting a 0 with unitary step increments:</p>
<pre><code class="language-rust no_run noplayground">    let mut signal: Initiator&lt;_&gt; = Signals::new(1, 20)
        .channel(0, Signal::Ramp { a: 1f64, b: 0f64 })
        .into();</code></pre>
<p>A rate transition can be imposed with the <a href="https://docs.rs/gmt_dos-actors/latest/gmt_dos_actors/clients/struct.Sampler.html">Sampler</a> client.
Here the input signal (<code>NI=1</code>) is downsampled according to <code>NO=DOWNRATE</code></p>
<pre><code class="language-rust no_run noplayground">   let mut downsampler: Actor&lt;_, 1, DOWNRATE&gt; = (
       Sampler::default(),
       format!(
           r&quot;1:{}
Downsampling&quot;,
           DOWNRATE
       ),
   )
       .into();</code></pre>
<p>Downsampling is also the results of the <a href="https://docs.rs/gmt_dos-actors/latest/gmt_dos_actors/clients/struct.Average.html">Average</a> client which averages the input over <code>NO/NI</code> samples:</p>
<pre><code class="language-rust no_run noplayground">    let mut averager: Actor&lt;_, 1, DOWNRATE&gt; = (
        Average::new(1),
        format!(
            &quot;1/{}
Average&quot;,
            DOWNRATE
        ),
    )
        .into();</code></pre>
<p>The downsampled and averaged signals, both with the same sampling rate (<code>DOWNRATE</code>), are recombined with the <code>SignedDiff</code> client which computes the difference between both signals and alternates the output sign.
By setting the output rates to <code>NO=UPRATE</code>, an upsampling rate transition will occur:</p>
<pre><code class="language-rust no_run noplayground">    let mut diff: Actor&lt;SignedDiff, DOWNRATE, UPRATE&gt; =
        (SignedDiff::new(), &quot;-(Y - A)*sign(x[i-1])&quot;).into();</code></pre>
<p>In the next step, we define 3 loggers, one for each sampling rate:</p>
<ul>
<li>1</li>
</ul>
<pre><code class="language-rust no_run noplayground">   let logging = Logging::&lt;f64&gt;::new(1).into_arcx();
   let mut logger = Terminator::&lt;_&gt;::new(logging.clone());</code></pre>
<ul>
<li><code>DOWNRATE</code></li>
</ul>
<pre><code class="language-rust no_run noplayground">  let down_logging = Logging::&lt;f64&gt;::new(2).into_arcx();
  let mut down_logger = Terminator::&lt;_, DOWNRATE&gt;::new(down_logging.clone()).name(
      &quot;Down
Logging&quot;,
  );</code></pre>
<ul>
<li><code>UPRATE</code></li>
</ul>
<pre><code class="language-rust no_run noplayground">  let up_logging = Logging::&lt;f64&gt;::new(1).into_arcx();
  let mut up_logger = Terminator::&lt;_, UPRATE&gt;::new(up_logging.clone()).name(
      &quot;Up
Logging&quot;,
  );</code></pre>
<p>Then it's a matter of defining inputs and outputs:</p>
<pre><code class="language-rust no_run noplayground">#[derive(UID)]
enum U {}
#[derive(UID, Clone)]
enum Y {}
#[derive(UID)]
enum A {}
#[derive(UID)]
enum Z {}
</code></pre>
<p>building the network:</p>
<pre><code class="language-rust no_run noplayground">  signal
      .add_output()
      .multiplex(3)
      .build::&lt;U&gt;()
      .into_input(&amp;mut logger)
      .into_input(&amp;mut downsampler)
      .into_input(&amp;mut averager)?;
  downsampler
      .add_output()
      .multiplex(2)
      .build::&lt;Y&gt;()
      .into_input(&amp;mut diff)
      .into_input(&amp;mut down_logger)?;
  averager
      .add_output()
      .multiplex(2)
      .build::&lt;A&gt;()
      .into_input(&amp;mut diff)
      .into_input(&amp;mut down_logger)?;
  diff.add_output().build::&lt;Z&gt;().into_input(&amp;mut up_logger)?;
</code></pre>
<p>and running the model:</p>
<pre><code class="language-rust no_run noplayground">  model!(
      signal,
      downsampler,
      diff,
      down_logger,
      logger,
      up_logger,
      averager
  )
  .name(&quot;multirate-model&quot;)
  .flowchart()
  .check()?
  .run()
  .await?;</code></pre>
<p>Finally, the logged ouputs are synchronized by post-proccessing the saved data while remembering that if the sampling rate of the ramp signal is 1 and its time step is <code>i</code>, then the time step of the downsampled and upsampled signals are derived from <code>DOWNRATE * (i + 1) - 1</code> and <code>UPRATE * i + DOWNRATE - 1</code>, respectively.</p>
<pre><code class="language-rust no_run noplayground">  let mut data: HashMap&lt;usize, Vec&lt;f64&gt;&gt; = HashMap::new();

  (*logging.lock().await)
      .chunks()
      .enumerate()
      .for_each(|(i, x)| data.entry(i).or_insert(vec![f64::NAN; 4])[0] = x[0]);

  (*down_logging.lock().await)
      .chunks()
      .enumerate()
      .for_each(|(i, x)| {
          data.entry(DOWNRATE * (i + 1) - 1)
              .or_insert(vec![f64::NAN; 4])[1..3]
              .iter_mut()
              .zip(x)
              .for_each(|(v, x)| *v = *x);
      });

  (*up_logging.lock().await)
      .chunks()
      .enumerate()
      .for_each(|(i, x)| {
          data.entry(UPRATE * i + DOWNRATE - 1)
              .or_insert(vec![f64::NAN; 4])[3] = x[0]
      });

  // Printing the time table
  let mut sorted_data: Vec&lt;_&gt; = data.iter().collect();
  sorted_data.sort_by_key(|data| data.0);
  println!(&quot;Step: [  U ,  Y  ,  A  ,  Z  ]&quot;);
  sorted_data
      .iter()
      .for_each(|(k, v)| println!(&quot;{:4}: {:4.1?}&quot;, k, v));</code></pre>
<p><img src="gmt-actor-model/clients/multirate/multirate_out.png" alt="Multirate logs" /></p>
<h4 id="implementation-of-the-signeddiff-client"><a class="header" href="#implementation-of-the-signeddiff-client">Implementation of the <code>SignedDiff</code> client:</a></h4>
<pre><code class="language-rust no_run noplayground">pub struct SignedDiff {
    left: Arc&lt;Data&lt;Y&gt;&gt;,
    right: Arc&lt;Data&lt;A&gt;&gt;,
    delta: Option&lt;Vec&lt;f64&gt;&gt;,
}
impl SignedDiff {
    pub fn new() -&gt; Self {
        Self {
            left: Arc::new(Data::new(vec![])),
            right: Arc::new(Data::new(vec![])),
            delta: None,
        }
    }
}
impl Update for SignedDiff {
    fn update(&amp;mut self) {
        self.left
            .iter()
            .zip(self.right.iter())
            .map(|(l, r)| l - r)
            .zip(self.delta.get_or_insert(vec![0f64; (**self.left).len()]))
            .for_each(|(d, delta)| *delta = -d * delta.signum());
    }
}
impl Read&lt;A&gt; for SignedDiff {
    fn read(&amp;mut self, data: Arc&lt;Data&lt;A&gt;&gt;) {
        self.right = data.clone();
    }
}
impl Read&lt;Y&gt; for SignedDiff {
    fn read(&amp;mut self, data: Arc&lt;Data&lt;Y&gt;&gt;) {
        self.left = data.clone();
    }
}
impl Write&lt;Z&gt; for SignedDiff {
    fn write(&amp;mut self) -&gt; Option&lt;Arc&lt;Data&lt;Z&gt;&gt;&gt; {
        self.delta
            .as_ref()
            .map(|delta| Arc::new(Data::new(delta.clone())))
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="persistence"><a class="header" href="#persistence">Persistence</a></h1>
<p>Persistence refers to the notion that the state of a client is <em>reachable</em> after a model execution.
Once a model has ended, the actors within the model have been consumed but some clients are still available.
They are the clients from actors that have been given the client pointer and not the client itself. 
We have already witnessed the persistence of the clients in the previous section with the <code>Logging</code> clients from which data is processed after the models have been terminated.</p>
<p>In the following, we are going to make use of this property of the clients to update a model at different stage of its execution.</p>
<p>The model is a feedback loop system which is bootstrapped with a low gain (0.2) for 1s, then the gain is increased to 0.5 for another 3s and finally the sampling rate of the feedback loop is reduced to 1/100th for the rest of the simulation. </p>
<p>Lets first define the simulation sampling frequency (1kHz) and the durations of the 3 stages of the simulation:</p>
<pre><code class="language-rust no_run noplayground">    let sim_sampling_frequency = 1000; //Hz
    let sampling_frequency_hz = sim_sampling_frequency as f64;
    let bootstrap_duration = 1; // s
    let fast_high_gain_duration = 3; // s
    let slow_high_gain_duration = 4; // s</code></pre>
<p>The parameters above are used to defined the number of samples for each stage:</p>
<pre><code class="language-rust no_run noplayground">    let n_bootstrap = bootstrap_duration * sim_sampling_frequency;
    let n_fast_high_gain = fast_high_gain_duration * sim_sampling_frequency;
    let n_slow_high_gain = slow_high_gain_duration * sim_sampling_frequency;
    let n_step = n_bootstrap + n_fast_high_gain + n_slow_high_gain;</code></pre>
<p>The input signal is the sum of 3 signals: 2 sinusoides and some white noise:</p>
<pre><code class="language-rust no_run noplayground">    let signal = Signals::new(1, n_step)
        .channel(
            0,
            Signal::Sinusoid {
                amplitude: 0.5f64,
                sampling_frequency_hz,
                frequency_hz: 1_f64,
                phase_s: 0f64,
            } + Signal::Sinusoid {
                amplitude: 0.1f64,
                sampling_frequency_hz,
                frequency_hz: 10_f64,
                phase_s: 0.1f64,
            } + Signal::WhiteNoise(Normal::new(-1f64, 0.005)?),
        )
        .into_arcx();</code></pre>
<p>Next we set the other 2 persistent clients for:</p>
<ul>
<li>the feedback integral control with the gain set to default (0)</li>
</ul>
<pre><code class="language-rust no_run noplayground">    let integrator = Integrator::new(1).into_arcx();</code></pre>
<ul>
<li>and data logging </li>
</ul>
<pre><code class="language-rust no_run noplayground">    let logging = Logging::&lt;f64&gt;::new(2).into_arcx();</code></pre>
<p>For stage I and II, the models are the same, only the gain of the integral controller is updated to 0.2 for stage I and to 0.5 for stage II.
So we define a <a href="https://doc.rust-lang.org/rust-by-example/fn/closures.html">closure</a> that represents the model template for stage I and II:</p>
<pre><code class="language-rust no_run noplayground">    let model = |n| -&gt; anyhow::Result&lt;Model&lt;Unknown&gt;&gt; {
        let mut timer: Initiator&lt;_&gt; = Timer::new(n).into();
        let mut source: Actor&lt;_&gt; = Actor::new(signal.clone());
        let mut sum: Actor&lt;_&gt; = (Sum::default(), &quot;+&quot;).into();
        let mut feedback: Actor&lt;_&gt; = Actor::new(integrator.clone());
        let mut logger: Terminator&lt;_&gt; = Actor::new(logging.clone());

        timer.add_output().build::&lt;Tick&gt;().into_input(&amp;mut source)?;
        source
            .add_output()
            .multiplex(2)
            .build::&lt;U&gt;()
            .into_input(&amp;mut sum)
            .into_input(&amp;mut logger)?;
        sum.add_output()
            .multiplex(2)
            .build::&lt;E&gt;()
            .into_input(&amp;mut feedback)
            .into_input(&amp;mut logger)?;
        feedback
            .add_output()
            .bootstrap()
            .build::&lt;Y&gt;()
            .into_input(&amp;mut sum)?;

        Ok(model!(timer, source, sum, feedback, logger))
    };</code></pre>
<p>The only argument to the closure is the duration <code>n</code> of each stage.
In addition to the actors of the <code>signal</code>, <code>integrator</code> and <code>logging</code> clients, actors for the <code>Timer</code> and the <code>Sum</code> clients were added.
The <code>Sum</code> client is the same that the one introduces in the <a href="gmt-actor-model/clients/persistence/../feedback/feedback.html">FeedBack System</a> section.</p>
<p>The model for stage I and II looks like this:</p>
<p><img src="gmt-actor-model/clients/persistence/persistence-stage-I.dot.svg" alt="stage I &amp; II model" /></p>
<h2 id="stage-i"><a class="header" href="#stage-i">Stage I</a></h2>
<p>For stage I, we create the model with the appropriate duration, set the integrator gain and run the model:</p>
<pre><code class="language-rust no_run noplayground">    let stage_i = model(n_bootstrap)?
        .name(&quot;persistence-stage-I&quot;)
        .flowchart()
        .check()?;
    (*integrator.lock().await).set_gain(0.2);
    let stage_i = stage_i.run();</code></pre>
<h2 id="stage-ii"><a class="header" href="#stage-ii">Stage II</a></h2>
<p>For stage II, we also start by creating the model with the appropriate duration, then we wait for stage I to finish before setting the integrator gain for stage II and running the model with the updated gain:</p>
<pre><code class="language-rust no_run noplayground">    let stage_ii = model(n_fast_high_gain)?
        .name(&quot;persistence-stage-II&quot;)
        .flowchart()
        .check()?;
    stage_i.await?;
    (*integrator.lock().await).set_gain(0.5);
    let stage_ii = stage_ii.run();</code></pre>
<h2 id="stage-iii"><a class="header" href="#stage-iii">Stage III</a></h2>
<p>For stage III, the feedback loop sampling rate is reduced by a factor 100:</p>
<pre><code class="language-rust no_run noplayground">const C: usize = 100;</code></pre>
<p>The input signal is average over 100 samples and the output signal is upsampled by a factor 100 as well.
Considering the above, the stage III actors are:</p>
<pre><code class="language-rust no_run noplayground">    let mut source: Initiator&lt;_&gt; = Actor::new(signal.clone());
    let mut avrg: Actor&lt;_, 1, C&gt; = Average::new(1).into();
    let mut sum: Actor&lt;_, C, C&gt; = (Sum::default(), &quot;+&quot;).into();
    let mut feedback: Actor&lt;_, C, C&gt; = Actor::new(integrator.clone());
    let mut upsampler: Actor&lt;_, C, 1&gt; = Sampler::new(vec![0f64]).into();
    let mut logger: Terminator&lt;_&gt; = Actor::new(logging.clone());</code></pre>
<p>We removed the <code>Timer</code> client and added actors for the <code>Average</code> and <code>Sampler</code> clients and we are still using the same <code>Signals</code>, <code>Integrator</code> and <code>Logging</code> clients but in the state they will be at the end of stage II.</p>
<p>The stage III network is build next:</p>
<pre><code class="language-rust no_run noplayground">    source
        .add_output()
        .multiplex(2)
        .build::&lt;U&gt;()
        .into_input(&amp;mut avrg)
        .into_input(&amp;mut logger)?;
    avrg.add_output().build::&lt;U&gt;().into_input(&amp;mut sum)?;
    sum.add_output()
        .multiplex(2)
        .build::&lt;E&gt;()
        .into_input(&amp;mut feedback)
        .into_input(&amp;mut upsampler)?;
    upsampler
        .add_output()
        .bootstrap()
        .build::&lt;E&gt;()
        .into_input(&amp;mut logger)?;
    feedback
        .add_output()
        .bootstrap()
        .build::&lt;Y&gt;()
        .into_input(&amp;mut sum)?;</code></pre>
<p><img src="gmt-actor-model/clients/persistence/persistence-stage-III.dot.svg" alt="stage III model" /></p>
<p>The <code>Sampler</code> output had to be bootstrapped as the input is delayed by 100 samples.
That is the reason why the <code>Sampler</code> has been creating with a default input value:</p>
<pre><code class="language-rust no_run noplayground">    let mut upsampler: Actor&lt;_, C, 1&gt; = Sampler::new(vec![0f64]).into();</code></pre>
<p>Finally, we create the new model, waiting for stage II to finish before running it:</p>
<pre><code class="language-rust no_run noplayground">    let stage_iii = model!(source, avrg, sum, feedback, upsampler, logger)
        .name(&quot;persistence-stage-III&quot;)
        .flowchart()
        .check()?;
    stage_ii.await?;
    stage_iii.run().await?;</code></pre>
<p>The logged data is plotted with:</p>
<pre><code class="language-rust no_run noplayground">    let _: complot::Plot = (
        (*logging.lock().await)
            .chunks()
            .enumerate()
            .map(|(i, data)| (i as f64 / sampling_frequency_hz, data.to_vec())),
        complot::complot!(&quot;persistence.png&quot;, xlabel = &quot;Time [s]&quot;),
    )
        .into();</code></pre>
<p>The blue curve is the input signal (U) and the orange curve is the residual signal (E) at the output of the sum.</p>
<p><img src="gmt-actor-model/clients/persistence/persistence.png" alt="3 stages model" /></p>
<p>The data corresponding to the transition for one stage to the next is displayed with:</p>
<ul>
<li>stage I to stage II transition:</li>
</ul>
<pre><code class="language-rust no_run noplayground">   println!(&quot;Stage I to Stage II transition:&quot;);
   (*logging.lock().await)
       .chunks()
       .enumerate()
       .skip(n_bootstrap - 5)
       .take(10)
       .for_each(|(i, x)| println!(&quot;{:4}: {:+.3?}&quot;, i, x));</code></pre>
<p><img src="gmt-actor-model/clients/persistence/persistence_out1.png" alt="stage I to stage II transition" /></p>
<ul>
<li>stage II to stage III transition:</li>
</ul>
<pre><code class="language-rust no_run noplayground">   println!(&quot;Stage II to Stage III transition:&quot;);
   (*logging.lock().await)
       .chunks()
       .enumerate()
       .skip(n_bootstrap + n_fast_high_gain - 5)
       .take(10)
       .for_each(|(i, x)| println!(&quot;{:4}: {:+.3?}&quot;, i, x));</code></pre>
<p><img src="gmt-actor-model/clients/persistence/persistence_out2.png" alt="stage II to stage III transition" /></p>
<p>and the data accross the end of the 1st integration of stage III</p>
<pre><code class="language-rust no_run noplayground">   println!(&quot;Stage III (1st integration):&quot;);
   (*logging.lock().await)
       .chunks()
       .enumerate()
       .skip(C + n_bootstrap + n_fast_high_gain - 5)
       .take(10)
       .for_each(|(i, x)| println!(&quot;{:4}: {:+.3?}&quot;, i, x));</code></pre>
<p><img src="gmt-actor-model/clients/persistence/persistence_out3.png" alt="stage III 1st integration" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aggregation"><a class="header" href="#aggregation">Aggregation</a></h1>
<p>Aggregation refers to the process of generating a larger model from existing models and actors.
The aggregation function is implemented with the <a href="https://doc.rust-lang.org/std/ops/trait.Add.html">Add</a> trait.</p>
<p>For example, the actors in the <a href="gmt-actor-model/aggregation/../clients/multirate/multirate.html">multirate</a> section could have been sorted out according to their sampling rates into 3 different models</p>
<ul>
<li>1</li>
</ul>
<pre><code class="language-rust no_run noplayground">   let one = model!(signal, logger)
       .name(&quot;nominal-sampling-rate&quot;)
       .flowchart();</code></pre>
<p><img src="gmt-actor-model/aggregation/nominal-sampling-rate.dot.svg" alt="Multirate model" /></p>
<ul>
<li><code>DOWNRATE</code></li>
</ul>
<pre><code class="language-rust no_run noplayground">  let quarter = model!(downsampler, averager, down_logger)
      .name(&quot;quarter-sampling-rate&quot;)
      .flowchart();</code></pre>
<p><img src="gmt-actor-model/aggregation/quarter-sampling-rate.dot.svg" alt="Multirate model" /></p>
<ul>
<li><code>UPRATE</code></li>
</ul>
<pre><code class="language-rust no_run noplayground">  let half = model!(diff, up_logger)
      .name(&quot;half-sampling-rate&quot;)
      .flowchart();</code></pre>
<p><img src="gmt-actor-model/aggregation/half-sampling-rate.dot.svg" alt="Multirate model" /></p>
<p>The complete model is then written:</p>
<pre><code class="language-rust no_run noplayground">  (one + quarter + half)
      .name(&quot;multirate-aggregated-model&quot;)
      .flowchart()
      .check()?
      .run()
      .await?;</code></pre>
<p><img src="gmt-actor-model/aggregation/multirate-aggregated-model.dot.svg" alt="Multirate model" /></p>
<p>Aggregation applies to both actors and models with the same outcome: a new model.
Below is the table of the types that can be aggregated into a model:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"><code>LHS</code></th><th style="text-align: center">+</th><th style="text-align: center"><code>RHS</code></th><th style="text-align: center">=</th><th style="text-align: center"><code>Add::Output</code></th></tr></thead><tbody>
<tr><td style="text-align: center"><code>Model</code></td><td style="text-align: center">+</td><td style="text-align: center"><code>Model</code></td><td style="text-align: center">=</td><td style="text-align: center"><code>Model</code></td></tr>
<tr><td style="text-align: center"><code>Model</code></td><td style="text-align: center">+</td><td style="text-align: center"><code>Actor</code></td><td style="text-align: center">=</td><td style="text-align: center"><code>Model</code></td></tr>
<tr><td style="text-align: center"><code>Actor</code></td><td style="text-align: center">+</td><td style="text-align: center"><code>Model</code></td><td style="text-align: center">=</td><td style="text-align: center"><code>Model</code></td></tr>
<tr><td style="text-align: center"><code>Actor</code></td><td style="text-align: center">+</td><td style="text-align: center"><code>Actor</code></td><td style="text-align: center">=</td><td style="text-align: center"><code>Model</code></td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
